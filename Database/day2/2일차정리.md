# DB 심화

## DB 관계 종류

- 1:1
  - A 테이블의 하나의 레코드가 B 테이블의 하나의 레코드와 연결된 경우
  - ex) 각 사용자는 하나의 프로필을 가짐(사용자:프로필 = 1:1)
  - ex2) 각 주문은 하나의 결제 정보를 가짐(주문:정보 = 1:1)

- 1:N
  - A 테이블의 하나의 레코드가 B 테이블의 여러 레코드와 연결된 경우
  - ex) 하나의 게시글에 여러 개의 댓글을 작성 가능(게시글:댓글 = 1:N)
    - 하나의 댓글은 여러 개의 게시글에 포함될 수 없음
  - ex2) 우리 반에는 여러 교육생들이 있다(반:교육생 = 1:N)

- M:N
  - A 테이블의 여러 레코드가 B 테이블의 여러 레코드와 연결된 경우
  - ex) 한 게시글에 여러 명이 좋아요를 누를 수 있음, 한 명이 여러 개의 게시글에 좋아요를 누를 수있다 (게시글:유저 = M:N)
  - ex) 여러 학생이 여러 과목을 듣는다 (학생:과목 = M:N)

## 외래키는 어느 테이블에 두어야 할까?

- 1:1
  - 시스템에서 조회가 많은 쪽으로
  - ex) 프로필 테이블 <-> 사용자 테이블
    - 내 시스템에서 프로필을 통해서 사용자를 많이 조회하네 -> 프로필 테이블에 외래키
- 1:N
  - N 쪽에 있어야함
  - ex) 소속회사 테이블에 "마블" 이 저장되어 있다고 가정
    - 해당 데이터를 가지고 가서 여러 군데에 동시에 사용함
    - 외래키는 참조하는 쪽에서 가지고 있어야함
- M:N
  - 중계 테이블 생성해야 한다
  - ex) 여러 학생이 여러 과목 수강
    - 학생 1<->N 중계 N<->1 과목

## DB 에서 KEY 란 ?

- 데이터베이스 테이블에서 특정 레코드를 고유하게 식별할 수 있는 필드 또는 필드 집합
  - 데이터를 검색하거나 조작할 때, KEY 값을 사용해서 특정 레코드를 식별

- KEY 의 종류

1. 기본키(Primary key)
   - 테이블 내에서 각각의 레코드를 식별하는 역할을 수행하는 필드
   - 유일한(중복되지 않고) NULL 값을 수 없는 값

2. 외래키(Foreign key)
   - 하나의 테이블에서 다른 테이블의 기본키(PK)를 참조하는 필드
   - 두 개 이상의 테이블을 연결할 때 사용
   - 얘는 반드시 써야하나 ?
     - 개발자의 실수를 막기 위해서(데이터의 무결성을 유지하기 위해) DB가 "제약 조건"을 거는 것
   - 장점
     - 데이터의 무결성이 보장된다(즉, 사용자가 만들 수 있는 에러가 많이 줄어든다!)
   - 단점
     - 체크해야 할 사항이 많아짐 -> 리소스(오버헤드)가 더 발생


[참고]추가로 공부하세요!
3. 후보키(Candidate Key): 기본키로 사용할 수 있는 필드(속성)로, 중복되지 않고 null 값을 가질 수 없는 유일한 값
    - 하나의 테이블 내에서 기본키는 하나만 존재할 수 있지만, 후보키는 여러 개 존재할 수 있음
    - 후보키는 테이블에서 특정 필드를 기준으로 조회할 때 유용하게 사용됨
    - 일반적으로 기본키는 사용자가 직접 정의하지만, 후보키는 데이터의 특성에 따라 자동으로 생성될 수도 있음
    - 후보키로 사용되는 필드는 반드시 유일성을 만족해야 함
4. 복합키(Composite key): 테이블에서 행을 유일하게 구분하기 위해 두 개 이상의 속성을 조합하여 사용하는 기본키
5. 대체키(Alternate Key): 후보키 중에서 선택된 기본키가 될 수 있는 키
    - 테이블에서 기본키로 사용할 수 있는 후보키가 여러 개인 경우 그 중에서 한 개의 후보키를 선택해 기본키로 지정하면, 나머지 후보키들은 대체키
6. 슈퍼키(Super Key): 릴레이션에서 유일성을 보장하는 속성 또는 속성들의 집합
    - 슈퍼키는 후보키와 기본키의 상위 개념으로, 유일성만을 만족하면 되므로 최소성을 만족하지 않을 수도 있다
    - 슈퍼키 중에서 후보키가 되는 것은 유일성과 최소성을 모두 만족하는 것을 의미


## 정규화(테이블 분리하기)

- 데이터의 구조를 더 좋은 구조로 바꾸는 과정
  - 테이블을 나누거나, 합치는 과정
- 목표
  - 데이터의 중복 최소화
  - 데이터의 무결성을 보장하기 위함
- 총 6단계의 정규형이 존재함
- [사전지식] 다음 정규형을 위해서는 이전 정규형이 반드시 완료되어야 한다.
- 기본 정규형(4개)
  - 제1정규형(1NF)
    - 모든 속성이 원자값(Atomic Value)을 가지도록 테이블을 구성하는 것
    - 즉, 각 속성이 하나의 값만을 가지도록 하는 것
    - 목표: 테이블 간 중복되는 데이터가 없도록 하기 위함
  - 제2정규형(2NF)
    - 테이블이 1NF 이어야 한다.
    - 테이블 내의 모든 컬럼은 해당 테이블의 주식별자(PK)에만 종속되어야 한다.
    - 즉, 관계가 없는 데이터끼리 묶지 않기 위해서 따로 분리하는 과정
  - 제3정규형(3NF)
      - 테이블이 2NF 이어야 한다.
      - 테이블 내의 모든 컬럼은 해당 엔티티의 주식별자(PK)에만 종속되어야 한다.
      - 2NF 정규형에서는 주식별자(PK)가 아닌 컬럼 간의 종속 관계를 제거하는 것이 목적이었지만, 3NF에서는 컬럼 간의 이행적 종속 관계(transitive dependency)를 제거하기 위한 것이 목적이다.
    - BCNF(보이스/코드 정규형)
      - 테이블이 3NF 이어야 한다.
      - 테이블 내의 모든 결정자는 후보키(Candidate Key)이어야 한다.
      - 제 3정규형을 조금 더 강화시킨 개념.
      - 이전 정규형들에서는 결정자가 후보키가 아닌 경우 이를 분리하기 위해 정규화를 수행했다면, BCNF에서는 결정자가 후보키가 아닌 경우 이를 보정하기 위해 정규화를 수행한다.
      - 모든 결정자는 항상 후보키가 되도록 릴레이션을 분해
- 고급 정규형
  - 제4정규형(4NF)
    - 테이블이 BCNF 이어야 한다.
    - 테이블 내에서 다중값 종속(MVD)을 제거하기 위한 정규화 기법
    - 다중값 종속(MVD)이란, 한 엔터티의 속성들이 여러 개의 집합으로 분해되어 있을 때 발생하는 종속성을 말한다.
  - 제5정규형(5NF)
    - 테이블이 4NF 이어야 한다.
    - 테이블 내에서 조인 종속(JD)을 제거하기 위한 정규화 기법
    - 조인 종속(JD)이란, 테이블 간의 조인으로 인해 발생하는 종속성을 말한다. 이를 제거하여 테이블 간의 조인이 필요하지 않도록 한다.

## 외래키 설정

- sqlite 는 기본적으로 가볍게 사용하기 위한 DB
  - 외래키 제약 조건을 비활성화 해놓았다.
- 외래키 제약조건 설정 방법
```
$ sqlite3 superhero.sqlite3

# 제약조건 확인하기: 0: OFF, 1: ON
# sqlite> PRAGMA foreign_keys;

# 제약조건 설정하기
# sqlite> PRAGMA foreign_keys = 1;

# 제약조건에 위배되는 데이터 삽입 
$ sqlite> INSERT INTO power(hero_id, 능력) VALUES (200, '몰라');

-> Error: FOREIGN KEY constraint failed 확인
```

## JOIN

- 참고사이트: https://commons.wikimedia.org/wiki/File:SQL_Joins.svg

- CROSS JOIN (또는 CARTESIAN JOIN)
  - 두 테이블의 모든 가능한 조합을 선택함
- INNER JOIN
  - 두 테이블에서 일치하는 값을 가진 행들만 선택
- LEFT JOIN (또는 LEFT OUTER JOIN)
  - 왼쪽 테이블의 모든 행과 오른쪽 테이블에서 일치하는 값을 가진 행을 선택
  - 일치하는 값이 없는 경우에는 NULL 값을 가짐
- RIGHT JOIN (또는 RIGHT OUTER JOIN)
  - 오른쪽 테이블의 모든 행과 왼쪽 테이블에서 일치하는 값을 가진 행을 선택
  - 일치하는 값이 없는 경우에는 NULL 값을 가짐
  - 원래 LEFT JOIN 이 표준인데, 참고 테이블을 적기 힘든 특수한 경우를 위해 추가됨
  - SQLITE 에서는 지원 안함
- FULL OUTER JOIN (또는 FULL JOIN)
  - 두 테이블에서 모든 행을 선택
  - 일치하는 값이 없는 경우에는 NULL 값을 가짐
- SELF JOIN
  - 자기 자신과 조인
  - ex) 사원 테이블 -> 이름, 직책, 매니저 필드를 가지고 있을 때 -> 직속 상관을 가져오는 방법
  - 참고사이트: [http://egloos.zum.com/sweeper/v/3002332](http://egloos.zum.com/sweeper/v/3002332)

## 추가 내용

- 성능 개선
  - 인덱스(Index)
    - 검색, 정렬 속도를 빠르게 하기 위해 사용




